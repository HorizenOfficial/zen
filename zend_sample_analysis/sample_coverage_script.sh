#!/bin/bash

#########################################
# Sample script for local code analysis #
#########################################

#### Compiling zend with coverage enabled
BUILDDIR="base directory where zend repository has been cloned"
cd $BUILDDIR

# Get the current commit hash
export COMMIT=`git log -1 --format="%H"`

zcutils/build.sh --enable-lcov -j 12
make clean
make -j 12
# to check that code coverage has been succesfully enabled, each compilation
# unit should be paired by a corresponding .gcno file

#### execute code coverage for Boost test and Google test
# This command runs all the tests, generating the *.gcda hits files
# An high level schema of baseline, intermediate and filtered file generation is provided
# in the diagram of the attached fig. 1
# Briefly, in hte diagram each rounded box is a .info coverage report file generated by running
# lcov with on eof the following switch:
# -i option for creating the zero coverage init file (in yellow)
# -c option for capturing the actual execution coverage (in white)
# -r option for removing/filtering external dependencies from a .info file (in blue)
# -a option for aggregating multiple reports in one (in purple).
# The final total_coverage.info report is created by aggregating a baseline zero analysis
# for both zend and levelDB, and actual coverage of Boost and Google tests. These four reports
# all individually underwent an external dependency filtering operation prior to the
# aggregation.
# Details of the implementation are available in ${BUILDDIR}/Makefile.am
make cov
#### the final aggregated output report file of this stage is total_coverage.info

#### execute the code coverage for Python tests
python qa/zcash/full_test_suite.py rpc --rpc-extended --coverage
# This in turn calls qa/pull-tester/rpc-tests.sh -extended -coverage
# A summary of what is performed by this command has been added at the end
# of this file, in the ADDENDUM 1 section
#### The final output is py_test_coverage_0.info


#### Runs clang-tidy on the subset of files touhced by this commit (way faster!)
#### Reduced from contrib/ci-horizen/scripts/test/clang-tidy-launcher.sh
# Get the names of the files touched by this commit
export FILELIST=`git diff-tree --no-commit-id --name-only -r $COMMIT`
# Filter out all files which do not end with .cpp, .h and .cc
FILTEREDFILELIST=()
for i in $FILELIST;
do
    if [[ $i =~ .*\.cpp$ ]] || [[ $i =~ .*\.h$ ]] || [[ $i =~ .*\.tcc$ ]];
    then
        FILTEREDFILELIST+=($i)
    fi
done
# Run Clang-Tidy on the filtered list and send the report to Codacy (do not finalize)
clang-tidy --checks='cppcoreguidelines*, performance*, bugprone*' ${FILTEREDFILELIST[@]} | \
codacy-clang-tidy-linux-1.3.5 | \
curl -v -XPOST -L -H "project-token: $CODACY_TOKEN" \
    -H "Content-type: application/json" -d @- \
    "https://api.codacy.com/2.0/commit/$COMMIT/issuesRemoteResults"
####


#### Sending coverage reports
# This simulate the behaviour of the CI, as B/G tests reports are sent by a Travis task, 
# while Python test reports are sent by a different one
# They a esent twice, as our repository are mainly composed by .cpp and .h files, all
# written in C++. However, when sending the report with the -l CPP option, .h files are ignored.
# The opposite happens when using the -l C option. Specifying a custom set of file extensions
# for the C++ language on the Codacy repository options page seems to have no effect on this.
bash <(curl -Ls https://coverage.codacy.com/get.sh) report --partial -l CPP --commit-uuid $COMMIT -r total_coverage.info
bash <(curl -Ls https://coverage.codacy.com/get.sh) report --partial -l C   --commit-uuid $COMMIT -r total_coverage.info
bash <(curl -Ls https://coverage.codacy.com/get.sh) report --partial -l CPP --commit-uuid $COMMIT -r py_test_coverage_0.info
bash <(curl -Ls https://coverage.codacy.com/get.sh) report --partial -l C   --commit-uuid $COMMIT -r py_test_coverage_0.info
### signal Codacy that all coverage files have been sent
bash <(curl -Ls https://coverage.codacy.com/get.sh) final --commit-uuid $COMMIT

#### super final command to trigger Codacy analysis
curl -v -XPOST -L -H "project-token: $CODACY_TOKEN" \
	-H "Content-type: application/json" \
	"https://api.codacy.com/2.0/commit/$COMMIT/resultsFinal"

exit 0
#### END OF THE EXPERIMENT


# So far we locally executed the operations that are performed by the CI.
# These are comprehensive of local static analysis, code coverage generation
# and interaction with Codacy API.
# For the sake of comparison, we generate a final aggregation of the 2 coverage report
# to create a final coverage index of the current commit evaluated so far
lcov -a py_test_coverage_0.info -a total_coverage.info -o merged_coverage.info
genhtml -s merged_coverage.info --legend --output-directory=merged_coverage

# I cannot be sure, but I presume it is more or less what happens on Codacy backend
# once all the coverage reports have been collected; however, for commit
# d89af61ae5d8750ea0539f5ed9bf95f0af44805d of branch ap/clangtidy_integr
# we obtain the following results:
#
# Overall coverage rate:
#   lines......: 75.2% (39951 of 53121 lines)
#   functions..: 75.6% (6030 of 7981 functions)
#
# while on the codacy Dashboard we see a coveage index of 67.51%






##### ADDENDUM 1
### Details on Python test coverage generation
### This follows lcov mand pages and documentation
### Also, we filter the same set of file as for Boost and Google tests
# Reset coverage 
lcov --directory "${BUILDDIR}"/src --zerocounters
# Collect zero coverage data
lcov -c -i -d "${BUILDDIR}/src" -o py_test_coverage_base.info -rc lcov_branch_coverage=1
# Filter zero coverage data
lcov -r py_test_coverage_base.info "/usr/include/*" \
                    "*/depends/x86_64-unknown-linux-gnu/include/*.h" \
                    "*/depends/x86_64-unknown-linux-gnu/include/boost/*" \
                    "*/depends/x86_64-unknown-linux-gnu/include/gmock/*" \
                    "*/depends/x86_64-unknown-linux-gnu/include/gtest/*" \
                    "*/src/gtest/*" \
                    "*/src/test/*" \
                    "*/src/wallet/gtest/*" \
                    "*/src/wallet/test/*" \
                    -o py_test_coverage_base_filtered.info
# Run the actual test suite
<run all the Python tests>
# Collect coverage data of test execution
lcov -c -d "${BUILDDIR}/src" -o py_test_coverage_after.info -rc lcov_branch_coverage=1
# Filter collected data
lcov -r py_test_coverage_after.info "/usr/include/*" \
    "*/depends/x86_64-unknown-linux-gnu/include/*.h" \
    "*/depends/x86_64-unknown-linux-gnu/include/boost/*" \
    "*/depends/x86_64-unknown-linux-gnu/include/gmock/*" \
    "*/depends/x86_64-unknown-linux-gnu/include/gtest/*" \
    "*/src/gtest/*" \
    "*/src/test/*" \
    "*/src/wallet/gtest/*" \
    "*/src/wallet/test/*" \
    -o py_test_coverage_after_filtered.info
# Aggregate with zero coverage data and save the final report
# (in this experiment, currentChunk is 0; in production several report are generated,
# each one corresponding to a subset of all the tests)
lcov -a py_test_coverage_base_filtered.info -a py_test_coverage_after_filtered.info -o py_test_coverage_"${currentChunk}".info
### The final output is py_test_coverage_0.info